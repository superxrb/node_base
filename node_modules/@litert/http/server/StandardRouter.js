"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = require("./Core");
const Exception_1 = require("./Exception");
const Errors_1 = require("./Errors");
const PlainRouteRule = require("./router-rules/Plain");
const RegExpRouteRule = require("./router-rules/RegExp");
const SmartRouteRule = require("./router-rules/Smart");
class Middleware {
}
class Router {
    constructor() {
        /**
         * Remove the sick type-assert error before TypeScript 2.7
         */
        // @ts-ignore
        this._regexpRouter = {};
        // @ts-ignore
        this._stringRouter = {};
        // @ts-ignore
        this._middlewares = {};
        for (let method of Core_1.HTTP_METHODS) {
            this._middlewares[method] = [];
        }
        this._notFoundHandler = async (ctx) => {
            ctx.response.writeHead(Core_1.HTTPStatus.NOT_FOUND, "FILE NOT FOUND");
            ctx.response.end();
        };
    }
    _setupMiddlewareRule(middleware, path) {
        if (typeof path === "string") {
            this._checkPath(path);
            if (path.indexOf("{")) {
                middleware.rule = new SmartRouteRule(null, path, {});
            }
            else {
                middleware.rule = new PlainRouteRule(null, path, {});
            }
        }
        else if (path instanceof RegExp) {
            middleware.rule = new RegExpRouteRule(null, path, {});
        }
    }
    use(...args) {
        let middleware = new Middleware();
        let arg0 = args[0];
        switch (args.length) {
            case 1:
                middleware.handler = args[0];
                break;
            case 2:
                if (Core_1.HTTP_METHODS.indexOf(arg0) > -1) {
                    middleware.method = arg0;
                }
                else if (Array.isArray(arg0)) {
                    for (let el of arg0) {
                        this.use(el, args[1]);
                    }
                    return this;
                }
                else {
                    this._setupMiddlewareRule(middleware, arg0);
                }
                middleware.handler = args[1];
                break;
            case 3:
                if (Array.isArray(arg0)) {
                    for (let method of arg0) {
                        this.use(method, arguments[1], arguments[2]);
                    }
                    return this;
                }
                if (Array.isArray(arguments[1])) {
                    for (let path of arguments[1]) {
                        this.use(arg0, path, arguments[2]);
                    }
                    return this;
                }
                middleware.method = arg0;
                this._setupMiddlewareRule(middleware, arguments[1]);
                middleware.handler = arguments[2];
        }
        if (middleware.method) {
            this._middlewares[middleware.method].push(middleware);
        }
        else {
            /**
             * Not limit to specific method.
             *
             * Thus adds it to all methods.
             */
            for (let method of Core_1.HTTP_METHODS) {
                this._middlewares[method].push(middleware);
            }
        }
        return this;
    }
    get(path, handler, data) {
        this.register("GET", path, handler, data);
        return this;
    }
    post(path, handler, data) {
        this.register("POST", path, handler, data);
        return this;
    }
    put(path, handler, data) {
        this.register("PUT", path, handler, data);
        return this;
    }
    patch(path, handler, data) {
        this.register("PATCH", path, handler, data);
        return this;
    }
    delete(path, handler, data) {
        this.register("DELETE", path, handler, data);
        return this;
    }
    options(path, handler, data) {
        this.register("OPTIONS", path, handler, data);
        return this;
    }
    head(path, handler, data) {
        this.register("HEAD", path, handler, data);
        return this;
    }
    trace(path, handler, data) {
        this.register("TRACE", path, handler, data);
        return this;
    }
    _checkPath(path) {
        if (path[0] !== "/"
            || path.indexOf("?") > -1
            || (path.length > 1 && path.endsWith("/"))) {
            throw new Exception_1.default(Errors_1.default.INVALID_PATH, "The URI is not acceptable.");
        }
    }
    register(method, path, handler, data = {}) {
        if (Array.isArray(method)) {
            for (let m of method) {
                this.register(m, path, handler, data);
            }
            return this;
        }
        if (path instanceof RegExp) {
            this._addRegExpRule(method, new RegExpRouteRule(handler, path, data));
        }
        else if (Array.isArray(path)) {
            for (let p of path) {
                this.register(method, p, handler, data);
            }
        }
        else {
            this._checkPath(path);
            let collection = this._stringRouter[method];
            if (!collection) {
                this._stringRouter[method] = collection = {};
            }
            if (path.indexOf("{") > -1) {
                this._addRegExpRule(method, new SmartRouteRule(handler, path, data));
            }
            else {
                collection[path] = new PlainRouteRule(handler, path, data);
            }
        }
        return this;
    }
    _addRegExpRule(method, rule) {
        let collection = this._regexpRouter[method];
        if (!collection) {
            this._regexpRouter[method] = collection = [];
        }
        collection.push(rule);
    }
    route(method, path, context) {
        let ret = {
            "middlewares": this._filterMiddlewares(method, path, context),
            "handler": null
        };
        if (!this._stringRouter[method] && !this._regexpRouter[method]) {
            ret.handler = this._notFoundHandler;
            context.data = {};
            return ret;
        }
        if (this._stringRouter[method] && this._stringRouter[method][path]) {
            ret.handler = this._stringRouter[method][path].handler;
            context.data = this._stringRouter[method][path].data || {};
            return ret;
        }
        if (this._regexpRouter[method]) {
            for (const route of this._regexpRouter[method]) {
                if (route.route(path, context)) {
                    ret.handler = route.handler;
                    context.data = route.data || {};
                    return ret;
                }
            }
        }
        ret.handler = this._notFoundHandler;
        context.data = {};
        return ret;
    }
    _filterMiddlewares(method, path, context) {
        let ret = [];
        for (let middleware of this._middlewares[method]) {
            if (middleware.rule && !middleware.rule.route(path, context)) {
                continue;
            }
            ret.push(middleware.handler);
        }
        return ret;
    }
    notFound(handler) {
        this._notFoundHandler = handler;
        return this;
    }
}
function default_1() {
    return new Router();
}
exports.default = default_1;
//# sourceMappingURL=StandardRouter.js.map