"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = require("./Core");
const DEFAULT_CONFIG = {
    "secureOnly": false,
    "httpOnly": false,
    "path": "/"
};
class DefaultEncoder {
    constructor(cfg) {
        this._encoding = cfg.encoding || Core_1.CookiesEncoding.PLAIN;
        if (!cfg.defaults) {
            this._defaults = DEFAULT_CONFIG;
        }
        else {
            this._defaults = {};
            for (let k in ["ttl", "secureOnly", "httpOnly", "path", "domain"]) {
                // @ts-ignore
                this._defaults[k] = cfg.defaults[k] || DEFAULT_CONFIG[k];
            }
        }
    }
    stringify(cfg) {
        let cookieText = [];
        let ttl = cfg.ttl || this._defaults.ttl;
        let secureOnly = cfg.secureOnly || this._defaults.secureOnly;
        let httpOnly = cfg.httpOnly || this._defaults.httpOnly;
        let domain = cfg.domain || this._defaults.domain;
        let path = cfg.path || this._defaults.path;
        switch (this._encoding) {
            case Core_1.CookiesEncoding.BASE64:
                cookieText.push(`${cfg.name}=${Buffer.from(cfg.value).toString("base64")}`);
                break;
            case Core_1.CookiesEncoding.HEX:
                cookieText.push(`${cfg.name}=${Buffer.from(cfg.value).toString("hex")}`);
                break;
            default:
                cookieText.push(`${cfg.name}=${cfg.value}`);
                break;
        }
        if (ttl) {
            let endTime = new Date(Date.now() + ttl * 1000);
            cookieText.push(`Expires=${endTime.toUTCString()}`);
            cookieText.push(`Max-Age=${ttl}`);
        }
        if (path) {
            cookieText.push(`Path=${encodeURI(path)}`);
        }
        if (domain) {
            if (domain[0] === "." || /^\d+(\.\d+){3}$/.test(domain)) {
                cookieText.push(`Domain=${domain}`);
            }
            else {
                cookieText.push(`Domain=.${domain}`);
            }
        }
        if (secureOnly) {
            cookieText.push(`Secure`);
        }
        if (httpOnly) {
            cookieText.push(`HttpOnly`);
        }
        return cookieText.join(";");
    }
    parse(cookies) {
        let ret = {};
        for (let item of cookies.split(";")) {
            item = item.trim();
            if (!item) {
                continue;
            }
            let pair = item.trim().split("=", 2);
            if (pair.length !== 2) {
                continue;
            }
            switch (this._encoding) {
                case Core_1.CookiesEncoding.BASE64:
                    ret[pair[0]] = Buffer.from(pair[1], "base64").toString();
                    break;
                case Core_1.CookiesEncoding.HEX:
                    ret[pair[0]] = Buffer.from(pair[1], "hex").toString();
                    break;
                default:
                    ret[pair[0]] = pair[1];
                    break;
            }
        }
        return ret;
    }
}
function createStandardCookiesEncoder(cfg) {
    return new DefaultEncoder(cfg || {});
}
exports.createStandardCookiesEncoder = createStandardCookiesEncoder;
//# sourceMappingURL=StandardCookiesEncoder.js.map